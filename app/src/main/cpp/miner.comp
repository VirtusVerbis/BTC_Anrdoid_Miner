// Bitcoin block header nonce scan: double-SHA256(header80) <= target.
// Unique work: nonce = nonceStart + gl_GlobalInvocationID.x; early-out if nonce > nonceEnd.
#version 450

// Host sets workgroup size via specialization constant ID 0 at pipeline creation (LocalSizeId).
layout(local_size_x_id = 0) in;

// UBO: 76 bytes header, 4 nonceStart, 4 nonceEnd, 32 target (pad to 128)
layout(set = 0, binding = 0) uniform Uniforms {
    uint header_0_3;   // bytes 0-3
    uint header_4_7;
    uint header_8_11;
    uint header_12_15;
    uint header_16_19;
    uint header_20_23;
    uint header_24_27;
    uint header_28_31;
    uint header_32_35;
    uint header_36_39;
    uint header_40_43;
    uint header_44_47;
    uint header_48_51;
    uint header_52_55;
    uint header_56_59;
    uint header_60_63;
    uint header_64_67;
    uint header_68_71;
    uint header_72_75; // bytes 72-75 (76th byte onwards = nonce)
    uint nonceStart;
    uint nonceEnd;
    uint target_0_3;
    uint target_4_7;
    uint target_8_11;
    uint target_12_15;
    uint target_16_19;
    uint target_20_23;
    uint target_24_27;
    uint target_28_31;
};

layout(set = 0, binding = 1) buffer Result {
    coherent uint resultNonce; // 0xFFFFFFFF = no win; first winner writes nonce
};

// SHA-256 K constants (first 16)
const uint K[64] = uint[64](
    0x428a2f98u, 0x71374491u, 0xb5c0fbcfu, 0xe9b5dba5u, 0x3956c25bu, 0x59f111f1u, 0x923f82a4u, 0xab1c5ed5u,
    0xd807aa98u, 0x12835b01u, 0x243185beu, 0x550c7dc3u, 0x72be5d74u, 0x80deb1feu, 0x9bdc06a7u, 0xc19bf174u,
    0xe49b69c1u, 0xefbe4786u, 0x0fc19dc6u, 0x240ca1ccu, 0x2de92c6fu, 0x4a7484aau, 0x5cb0a9dcu, 0x76f988dau,
    0x983e5152u, 0xa831c66du, 0xb00327c8u, 0xbf597fc7u, 0xc6e00bf3u, 0xd5a79147u, 0x06ca6351u, 0x14292967u,
    0x27b70a85u, 0x2e1b2138u, 0x4d2c6dfcu, 0x53380d13u, 0x650a7354u, 0x766a0abbu, 0x81c2c92eu, 0x92722c85u,
    0xa2bfe8a1u, 0xa81a664bu, 0xc24b8b70u, 0xc76c51a3u, 0xd192e819u, 0xd6990624u, 0xf40e3585u, 0x106aa070u,
    0x19a4c116u, 0x1e376c08u, 0x2748774cu, 0x34b0bcb5u, 0x391c0cb3u, 0x4ed8aa4au, 0x5b9cca4fu, 0x682e6ff3u,
    0x748f82eeu, 0x78a5636fu, 0x84c87814u, 0x8cc70208u, 0x90befffau, 0xa4506cebu, 0xbef9a3f7u, 0xc67178f2u
);

uint rotr(uint x, int n) {
    return (x >> n) | (x << (32 - n));
}

void sha256_transform(inout uint s[8], uint w[64]) {
    uint a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];
    for (int i = 16; i < 64; i++) {
        uint s0 = rotr(w[i-15], 7) ^ rotr(w[i-15], 18) ^ (w[i-15] >> 3);
        uint s1 = rotr(w[i-2], 17) ^ rotr(w[i-2], 19) ^ (w[i-2] >> 10);
        w[i] = w[i-16] + s0 + w[i-7] + s1;
    }
    for (int i = 0; i < 64; i++) {
        uint ch = (e & f) ^ (~e & g);
        uint maj = (a & b) ^ (a & c) ^ (b & c);
        uint ep0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22);
        uint ep1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25);
        uint t1 = h + ep1 + ch + K[i] + w[i];
        uint t2 = ep0 + maj;
        h = g; g = f; f = e; e = d + t1; d = c; c = b; b = a; a = t1 + t2;
    }
    s[0] += a; s[1] += b; s[2] += c; s[3] += d; s[4] += e; s[5] += f; s[6] += g; s[7] += h;
}

// First SHA-256: 80-byte input (one 64-byte block + one padded block)
void sha256_80bytes(uint header0_3, uint header4_7, uint header8_11, uint header12_15,
    uint header16_19, uint header20_23, uint header24_27, uint header28_31,
    uint header32_35, uint header36_39, uint header40_43, uint header44_47,
    uint header48_51, uint header52_55, uint header56_59, uint header60_63,
    uint header64_67, uint header68_71, uint header72_75, uint nonceLE,
    out uint out0, out uint out1, out uint out2, out uint out3,
    out uint out4, out uint out5, out uint out6, out uint out7) {
    uint s[8] = uint[8](0x6a09e667u, 0xbb67ae85u, 0x3c6ef372u, 0xa54ff53au, 0x510e527fu, 0x9b05688cu, 0x1f83d9abu, 0x5be0cd19u);
    uint w[64];
    w[0] = header0_3;  w[1] = header4_7;  w[2] = header8_11;  w[3] = header12_15;
    w[4] = header16_19; w[5] = header20_23; w[6] = header24_27; w[7] = header28_31;
    w[8] = header32_35; w[9] = header36_39; w[10] = header40_43; w[11] = header44_47;
    w[12] = header48_51; w[13] = header52_55; w[14] = header56_59; w[15] = header60_63;
    sha256_transform(s, w);
    // Second block: header64_67, header68_71, header72_75, nonceLE, 0x80, zeros, length 640
    w[0] = header64_67; w[1] = header68_71; w[2] = header72_75; w[3] = nonceLE;
    w[4] = 0x80000000u; w[5] = 0u; w[6] = 0u; w[7] = 0u; w[8] = 0u; w[9] = 0u; w[10] = 0u; w[11] = 0u;
    w[12] = 0u; w[13] = 0u; w[14] = 0u; w[15] = 0x00000280u; // length 640 bits (big-endian last 8 bytes)
    sha256_transform(s, w);
    out0 = s[0]; out1 = s[1]; out2 = s[2]; out3 = s[3]; out4 = s[4]; out5 = s[5]; out6 = s[6]; out7 = s[7];
}

// Second SHA-256: 32-byte input (one padded block)
void sha256_32bytes(uint h0, uint h1, uint h2, uint h3, uint h4, uint h5, uint h6, uint h7,
    out uint out0, out uint out1, out uint out2, out uint out3,
    out uint out4, out uint out5, out uint out6, out uint out7) {
    uint s[8] = uint[8](0x6a09e667u, 0xbb67ae85u, 0x3c6ef372u, 0xa54ff53au, 0x510e527fu, 0x9b05688cu, 0x1f83d9abu, 0x5be0cd19u);
    uint w[64];
    w[0] = h0; w[1] = h1; w[2] = h2; w[3] = h3; w[4] = h4; w[5] = h5; w[6] = h6; w[7] = h7;
    w[8] = 0x80000000u; w[9] = 0u; w[10] = 0u; w[11] = 0u; w[12] = 0u; w[13] = 0u; w[14] = 0u; w[15] = 0x00000100u; // 256 bits
    sha256_transform(s, w);
    out0 = s[0]; out1 = s[1]; out2 = s[2]; out3 = s[3]; out4 = s[4]; out5 = s[5]; out6 = s[6]; out7 = s[7];
}

// Compare 32-byte hash (8 uints big-endian) <= target (8 uints big-endian)
bool hash_meets_target(uint h0, uint h1, uint h2, uint h3, uint h4, uint h5, uint h6, uint h7) {
    if (h0 != target_0_3)  return h0 < target_0_3;
    if (h1 != target_4_7)  return h1 < target_4_7;
    if (h2 != target_8_11) return h2 < target_8_11;
    if (h3 != target_12_15) return h3 < target_12_15;
    if (h4 != target_16_19) return h4 < target_16_19;
    if (h5 != target_20_23) return h5 < target_20_23;
    if (h6 != target_24_27) return h6 < target_24_27;
    return h7 <= target_28_31;
}

void main() {
    uint global_id = gl_GlobalInvocationID.x;
    uint nonce = nonceStart + global_id;
    if (nonce > nonceEnd)
        return;

    // Nonce as 4 bytes little-endian in the 80-byte header (bytes 76-79)
    uint nonceLE = (nonce & 0xffu) | ((nonce >> 8) & 0xffu) << 8 | ((nonce >> 16) & 0xffu) << 16 | (nonce >> 24) << 24;

    uint o0, o1, o2, o3, o4, o5, o6, o7;
    sha256_80bytes(header_0_3, header_4_7, header_8_11, header_12_15,
        header_16_19, header_20_23, header_24_27, header_28_31,
        header_32_35, header_36_39, header_40_43, header_44_47,
        header_48_51, header_52_55, header_56_59, header_60_63,
        header_64_67, header_68_71, header_72_75, nonceLE,
        o0, o1, o2, o3, o4, o5, o6, o7);

    uint f0, f1, f2, f3, f4, f5, f6, f7;
    sha256_32bytes(o0, o1, o2, o3, o4, o5, o6, o7, f0, f1, f2, f3, f4, f5, f6, f7);

    if (hash_meets_target(f0, f1, f2, f3, f4, f5, f6, f7))
        atomicMin(resultNonce, nonce);
}
